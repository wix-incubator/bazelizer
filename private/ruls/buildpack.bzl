

_M2_REPO_IMG_EXT = ".tar"
_BASE_POM_NAME = "base_pom.xml"
_TOOL = Label("//private/tools/jvm/mvn:mvn")
_MARKER_SRC_DEFAULT_OUTPUT_JAR = "@@TARGET-JAR-OUTPUT@@"

MvnBuildpackInfo = provider(
    fields = {"pom": "pom file", "tarball": "archive m2 repository"},
)


def _setup_common_tool_falgs(ctx, args):
    if ctx.attr.log_level:
        args.add("--syslog=%s" % (ctx.attr.log_level))


def _merged_dict(dicta, dictb):
    return dict(dicta.items() + dictb.items())

_common_attr = {
    "log_level": attr.string(doc="specify log level for the tool")
}

_create_mvn_repository_attr = _merged_dict(
    _common_attr,
    {
        "pom_parent": attr.label(allow_single_file = True),
        "pom_file_vars": attr.string_dict(),
        "pom_file_init_src": attr.label(allow_single_file = True),
        "_tool": attr.label(default = _TOOL, allow_files = True, executable = True, cfg = "host"),
    }
)

def _create_mvn_repository_impl(ctx):
    _content_file = ctx.file.pom_file_init_src
    if _content_file:
        initial_pom = _content_file
    else:
        fail('Must use either "pom_file_init_content" or "pom_file_init_src" attr')

    archive = ctx.actions.declare_file(ctx.label.name + _M2_REPO_IMG_EXT)
    args = ctx.actions.args()
    _setup_common_tool_falgs(ctx, args)
    args.add("repo2tar")
    args.add("--output", archive.path)
    args.add("--pom", initial_pom.path)

    pom_parent_file = ctx.file.pom_parent
    transitive_input = []
    if pom_parent_file:
            args.add("--parent", pom_parent_file.path)
            transitive_input.append(depset([pom_parent_file]))

    ctx.actions.run(
        inputs = depset([initial_pom], transitive = transitive_input),
        outputs = [archive],
        arguments = [args],
        executable = ctx.executable._tool,
        use_default_shell_env = True,
        progress_message = "createing mvn repository tarball... %s" % (ctx.label),
    )

    return [
        platform_common.TemplateVariableInfo({'FOO': 'bar'}),
        DefaultInfo(files = depset([archive, initial_pom])),
        MvnBuildpackInfo(pom = initial_pom, tarball = archive),
    ]


create_mvn_buildpack = rule(
    implementation = _create_mvn_repository_impl,
    attrs = _create_mvn_repository_attr,
)

_create_mvn_repository_attr_outputs = {
    "image": "%{name}_img.tar",
}

_create_mvn_repository_attr_v2 = _merged_dict(
    _common_attr,
    {
        "pom_parent": attr.label(allow_single_file = True),
        "pom_file_vars": attr.string_dict(),
        "pom_file": attr.label(allow_single_file = True, mandatory = True),
        "_tool": attr.label(default = _TOOL, allow_files = True, executable = True, cfg = "host"),
    }
)


def _rlocation(ctx, file):
       return "${RUNFILES_DIR}/" + ctx.workspace_name + "/" + file.short_path

def _create_mvn_repository_impl_v2(ctx):
    pom_file = ctx.file.pom_file
    archive = ctx.outputs.image
    optional_transitive_inputs = [] # TODO

    args = ctx.actions.args()
    _setup_common_tool_falgs(ctx, args)
    args.add("repo2tar")
    args.add("--output", archive.path)
    args.add("--pom", pom_file.path)
    pom_parent_file = ctx.file.pom_parent
    if pom_parent_file:
            args.add("--parent", pom_parent_file.path)
            optional_transitive_inputs.append(depset([pom_parent_file]))

    ctx.actions.run(
        inputs = depset([pom_file], transitive = optional_transitive_inputs),
        outputs = [archive],
        arguments = [args],
        executable = ctx.executable._tool,
        use_default_shell_env = True,
        progress_message = "createing mvn repository tarball... %s" % (ctx.label),
    )

    # Write the wrapper.
    # There is a {rulename}.runfiles directory adjacent to the tool's
    # executable file which contains all runfiles. This is not guaranteed
    # to be relative to the directory in which the executable file is run.

    # Use java binary as maven executable
    java_binary_tool = ctx.workspace_name + "/" + ctx.attr._tool[DefaultInfo].files_to_run.executable.short_path

    # Since this tool may be used by another tool, it must support accepting
    # a different runfiles directory root. The runfiles directory is always
    # adjacent to the *root* tool being run, which may not be this tool.
    # (In this case, this is done by environment variable RUNFILES_DIR.)

    runfiles_relative_archive_path = _rlocation(ctx, archive)
    runfiles_relative_pom_path = _rlocation(ctx, pom_file)
    if pom_parent_file: runfiles_relative_parent_pom_path = _rlocation(ctx, pom_parent_file)

    script_args = " ".join([
        "build",
        "--pom={}".format(runfiles_relative_pom_path),
        "--repo={}".format(runfiles_relative_archive_path),
        "--parent={}".format(runfiles_relative_parent_pom_path) if pom_parent_file else ""
    ])

    executable = ctx.outputs.executable
    ctx.actions.write(
        output = executable,
        content = "\n".join([
            "#!/bin/bash",
            "# !! Autogenerated - do not edit !!",
            "if [[ -z \"${RUNFILES_DIR}\" ]]; then",
            "  RUNFILES_DIR=${0}.runfiles",
            "fi",
            "",
            "jvm_bin=${RUNFILES_DIR}/%s" % (java_binary_tool),
            "args=\"%s\"" % (script_args),
            "${jvm_bin} ${args} \"$@\""
        ]),
        is_executable = True,
    )

    runfiles = ctx\
        .runfiles(files = [pom_file, executable, archive, ctx.executable._tool])\
        .merge(ctx.attr._tool[DefaultInfo].default_runfiles)

    files_to_build = depset(direct=[executable], transitive = [
        depset([archive, pom_file] + optional_transitive_inputs)
    ])
    return [
        DefaultInfo(runfiles = runfiles, files = files_to_build),
    ]


create_mvn_buildpack_v2 = rule(
    implementation = _create_mvn_repository_impl_v2,
    attrs = _create_mvn_repository_attr_v2,
    outputs = _create_mvn_repository_attr_outputs,
    executable = True,
)


def _write_manifest_file(name, ctx, files_paths):
    manifest = ctx.actions.declare_file(name + ".manifest")
    args = ctx.actions.args()
    args.add_all(files_paths)
    ctx.actions.write(manifest, args)
    return manifest

def _collect_deps(dep_targets):
    # Collect only direct dependencies for each target
    _direct_deps = []
    for dep_target in dep_targets:
        # Expect only java compatible targets
        java_provider = dep_target[JavaInfo]

        # We should use full_compile_jars to omit interface jars (ijar and hjar)
        # as maven build required fully compiled jar files
        for d in java_provider.full_compile_jars.to_list():
            # Rule scala_import provide specific jar to collect all exports
            # so, we should exclude it
            if d.path.endswith("PlaceHolderClassToCreateEmptyJarForScalaImport.jar"):
                continue
            _direct_deps.append(d)

    return _direct_deps


_run_mvn_buildpack_attr = _merged_dict(
    _common_attr,
    {
        "deps": attr.label_list(),
        "srcs": attr.label_list(mandatory = True),
        "outputs": attr.string_list(),
        "artifactId": attr.string(),
        "groupId": attr.string(),
        "buildpack": attr.label(
            mandatory = True,
            allow_files = True,
            executable = True,
            cfg = "host",
        ),
        "_tool": attr.label(
            default = _TOOL,
            allow_files = True,
            executable = True,
            cfg = "host",
        )
    }
)


def _run_mvn_buildpack_impl(ctx):
#    buildpack_info = ctx.attr.buildpack[MvnBuildpackInfo]
    deps = _collect_deps(ctx.attr.deps)
    srcs_manifest = _write_manifest_file("srcs", ctx, [src for src in ctx.files.srcs])
    deps_manifest = _write_manifest_file("deps", ctx, [d.path for d in deps])
    outputs = []
    output_args = []
    output_param = "-O{declared_file}={file_in_mvn_target}"
    for o in ctx.attr.outputs:
        declare_file = ctx.actions.declare_file(o)
        outputs.append(declare_file)
        output_args.append(
            output_param.format(
                declared_file = declare_file.path,
                file_in_mvn_target = o
            )
        )
    out_jar = ctx.label.name + ".jar"
    declared_out_jar = ctx.actions.declare_file(out_jar)
    outputs.append(declared_out_jar)
    output_args.append(
        output_param.format(
            declared_file = declared_out_jar.path,
            file_in_mvn_target = _MARKER_SRC_DEFAULT_OUTPUT_JAR
        )
    )

    args = ctx.actions.args()
    _setup_common_tool_falgs(ctx, args)
#    args.add("build")
#    args.add("--pom", buildpack_info.pom)
#    args.add("--repo", buildpack_info.tarball)
    args.add("--srcs", srcs_manifest)
    args.add("--deps", deps_manifest)
    if ctx.attr.artifactId: args.add("--artifactId", ctx.attr.artifactId)
    if ctx.attr.groupId: args.add("--groupId", ctx.attr.groupId)
    args.add_all(output_args)

    ctx.actions.run(
        inputs = depset([srcs_manifest, deps_manifest],
                        transitive = [
#                            depset([buildpack_info.pom, buildpack_info.tarball]),
                            depset(deps)
                        ] + [f.files for f in ctx.attr.srcs]),
        outputs = outputs,
        arguments = [args],
        executable = ctx.executable.buildpack,
        use_default_shell_env = True,
        progress_message = "running maven build... %s" % (ctx.label),
    )

    runfiles = ctx.runfiles(files = outputs).merge(ctx.attr.buildpack[DefaultInfo].default_runfiles)

    return [
        DefaultInfo(files = depset(outputs), runfiles = runfiles),
        JavaInfo(output_jar = declared_out_jar, compile_jar = declared_out_jar)
    ]

run_mvn_buildpack = rule(
    implementation = _run_mvn_buildpack_impl,
    attrs = _run_mvn_buildpack_attr,
)
